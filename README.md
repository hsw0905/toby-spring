# toby-spring

## 데이터 접근 객체 (DAO)

## Chapter 1
### 관심사의 분리
- 공통된 기능 추출
  - 메소드 추출
  - 클래스 분리
    - 템플릿 메소드 패턴
    - 팩토리 메소드 패턴
    
- 상속을 통한 확장의 단점
  - 코드를 일일이 변경
  - 바뀔수 있는 정보에 대해 너무 많이 알고 있다.
  
- 인터페이스 도입
  - 자신을 구현한 클래스에 대한 구체적인 정보를 모두 감춰버린다.
  - 실제 구현 클래스를 바꿔도 신경 쓸 일이 없다.

  - 클래스가 아닌 오브젝트와 오브젝트 사이의 관계 설정
    - 두 오브젝트 사이의 관계 -> 런타임시 한쪽이 다른 오브젝트의 참조를 가지고 있다.

- 높은 응집도
  - 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다.
  - 즉, 코드를 바꿔야할 이유가 단 한가지 책임일 때
- 낮은 결합도
  - 하나의 코드 변경이 발생할 때 다른 모듈과 객체로 변경에 대한 요구가 전파되지 않는 상태

- 전략 패턴
  - 변경이 필요한 알고리즘(기능)을 인터페이스로 분리
  - 변경이 일어나는 구현체로 맥락에 따라 바꿔 사용

### 제어의 역전(IoC)
- 라이브러리(App 흐름을 능동적으로 제어) vs 프레임워크(프레임워크에 의해 코드가 수동적으로 사용됨)
- 모든 제어 권한을 자신이 아닌 다른 대상에 위임 (예: DaoFactory)
- 프레임워크 또는 컨테이너 같이 어플리케이션 컴포넌트의 생성, 관계설정, 생명주기, 사용 등을 관장하는 존재가 필요하다.

- Bean
  - 스프링이 직접 만들고 관계를 부여하는 오브젝트
  - 스프링에선 스프링이 제어권 소유
  - IoC가 적용된 객체

- Bean Factory
  - 빈의 생성과 관계 설정 같은 제어를 담당
  - IoC 방식

- Application Context
  - App 전반적으로 좀 더 확장된 IoC 엔진을 의미
  - 별도로 설정 정보가 담겨 있는 어딘가에서 정보를 가져와 활용

- 왜 굳이 Application Context를 사용하는가? 빈 팩토리를 직접 만들면 되지 않나
  - 필요할 때마다 팩토리를 따로 만들어야 하는 번거로움이 있다.
  - 또한 클라이언트가 팩토리 클래스를 일일이 알아야 한다.
  - 따라서 Application Context를 사용하면 일관된 방식으로 원하는 오브젝트를 가져올 수 있다.

